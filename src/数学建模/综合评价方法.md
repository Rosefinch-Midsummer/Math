# 综合评价方法

<!-- toc -->

# 层次分析法

层次分析法（Analytic Hierarchy Process, AHP）是一种用于决策制定的数学方法，广泛应用于复杂问题的多标准决策分析中。以下是对层次分析法的详细介绍：

## 1. 概述
层次分析法由美国运筹学家萨提（Thomas L. Saaty）在1970年代提出。该方法通过将复杂问题分解为多个层次，帮助决策者在各种选择中作出理性的、系统的选择。

## 2. 主要步骤

## 2.1 确定问题和目标
首先，明确需要解决的问题和决策目标。

## 2.2 建立层次结构
将决策问题分解为多个层次，通常包括：
- **目标层**：决策的主要目标。
- **准则层**：影响决策的主要准则（可以进一步细分为子准则）。
- **方案层**：可供选择的具体方案。

## 2.3 进行成对比较
决策者对各准则及方案进行成对比较，使用尺度（通常为1到9的比例尺度）表示其相对重要性：
- **1**：两个选项同等重要。
- **3**：一项稍微重要。
- **5**：一项相对重要。
- **7**：一项非常重要。
- **9**：一项绝对重要。

## 2.4 计算权重
根据成对比较的结果构建判断矩阵，利用特征值法计算各准则和方案的权重。权重反映了各要素在总体决策中的重要性。

## 2.5 一致性检验
在判断过程中，需要检验成对比较的一致性，确保决策的合理性。常用的一致性比例（CR）来判断：
- $CR < 0.1$：一致性可以接受。
- $CR \geq 0.1$：需要调整判断。

## 2.6 综合评分
将方案的权重与准则的权重相结合，计算出各方案的综合得分，从而做出最终决策。

## 3. 优点
- **结构化**：将复杂问题分解，易于理解。
- **系统性**：提供一套步骤，可以重复使用。
- **灵活性**：适用于多种类型的决策。
- **定量与定性结合**：兼顾定量数据和决策者的主观判断。

## 4. 缺点
- **主观性**：成对比较可能受个人偏见影响。
- **一致性问题**：实际决策中，保持一致性可能较难。
- **复杂度**：对于层次结构复杂的问题，计算量可能较大。

## 5. 应用领域
层次分析法广泛应用于：
- 项目评估与选择
- 风险分析
- 资源分配
- 供应商选择
- 市场调研

## 6. 结论
层次分析法是一种强大的决策支持工具，能够帮助决策者更系统地分析问题，从而做出更为合理的选择。在使用时，需要注意主观判断的影响，加强一致性检验，以提高决策的有效性。

## 解题步骤


![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250120164924.png)

基本步骤：

Step1：解决评价类问题

Step2：画出层级结构图——目标层、准则层、方案层（出现在论文里）

Step3：构造判断矩阵 （确定评价指标孰重孰轻）

Step4：依照评价指标对各个方案进行打分 

Step5：求出权重，填表，求得最后得分 

Step6：层次总排序一致性检验

## 应用

![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20241228104224.png)


# 模糊综合评价

模糊综合评价（Fuzzy Comprehensive Evaluation，FCE）是一种基于模糊集合理论的方法，主要用于处理复杂决策和评价问题，特别是当评价对象的属性不易用精确数值表示时。该方法能够结合定性与定量分析，以较高的符合度来反映实际情况。

## 概论

![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20241229094555.png)

以下是模糊综合评价的详细介绍：
### 1. 概述

模糊综合评价方法利用模糊逻辑处理不确定性和不精确性，适用于多指标的评价问题。其主要目标是将定性信息转化为定量分析，提供更灵活的决策支持。

什么是模糊？

现实中的许多现象及关系比较模糊，如高与矮，长与短，大与小，多与少，穷与富，好与差，年轻与年老等。这类现象不满足“非此即彼”的排中律，而具有“亦此亦彼”的模糊性.需要指出的是，模糊不确定不同于随机不确定。

随机不确定是因果律破损造成的不确定，而模糊不确定是由于排中律破损造成的不确定。

确定的量（是啥就是啥）：高等数学、线性代数

不确定的量（是啥不一定是啥）：随机性（概率论）、灰性（灰色统计，在后面会讲）、模糊性

![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20241229092613.png)


![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20241229092834.png)

如何确定隶属函数？三分法（了解）
### 2. 主要步骤

#### 2.1 确定评价目标
明确需要评价的对象和目标，确立评价的基本范围。

#### 2.2 建立评价指标体系
- 确定评价指标，包括主观和客观指标，通常根据实际情况选择多个相关指标。
- 将指标分为不同的层次，形成一个系统的评价框架。

#### 2.3 确定评价集和权重
- **评价集**：根据评价指标的性质，构建模糊评价集（将评价对象的特征用语言描述）。
- **权重**：通过专家打分或成对比较的方法为各个指标赋予权重，反映其在总体评价中的相对重要性。

#### 2.4 模糊评判
- 利用模糊矩阵，对每一评价对象在各个指标上的表现进行模糊化处理。通常使用模糊数（例如，通过三角形或梯形模糊数）描述评价等级。
- 进行成对比较，建立评价对象与指标之间的模糊关系。

#### 2.5 综合评价
通过模糊运算，将各个指标的评价结果与权重相结合，形成综合评价结果。常用的方法包括：
- **模糊加权求和**：将每个指标的模糊评价与其权重相乘，然后求和。
- **模糊乘积法**：将各个模糊数相乘，得到最终的模糊评价结果。

#### 2.6 提取清晰结果
将模糊评价结果进行清晰化处理，得到一个具体的评价结果。常见的清晰化方法包括重心法、最大隶属度法等。

### 3. 优点
- **处理不确定性**：能够有效处理复杂的、多变的、不明确的信息，适合模糊性问题。
- **灵活性**：适用于多种类型的评价问题，具有较强的适应性。
- **量化与质化结合**：通过模糊理论，将定性评价与定量分析结合起来，提供综合性的判断。

### 4. 缺点
- **主观性**：评价结果依赖于专家的主观判断，可能受到个人因素影响。
- **复杂度**：在构造模糊评价集和权重时，可能需要大量的专家意见，增加了计算的复杂性。
- **计算负担**：对于多层次的评价系统，计算量较大，可能导致效率下降。

### 5. 应用领域
模糊综合评价方法广泛应用于多个领域，包括：
- 环境评价
- 经济效益分析
- 项目评估
- 风险管理
- 教育评价
- 产品质量评价

### 6. 结论
模糊综合评价是一种有效的决策支持工具，能够在不确定性较高的情况下提供合理的、可操作的决策结果。在具体应用中，需要注意评价指标的选择和模糊数的构建，以确保评价的科学性与合理性。

## 一级模糊综合评价

![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20241230090305.png)
## 多级模糊综合评价

二级模糊综合评价之Python代码实现

![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20241230085509.png)

```python
import numpy as np

def fuzzy_evaluation():

    # 输入评价矩阵
    eval_mat = np.array([[0.8, 0.15, 0.05, 0, 0],
                         [0.2, 0.6, 0.1, 0.1, 0],
                         [0.5, 0.4, 0.1, 0, 0],
                         [0.1, 0.3, 0.5, 0.05, 0.05],
                         [0.3, 0.5, 0.15, 0.05, 0],
                         [0.2, 0.2, 0.4, 0.1, 0.1],
                         [0.4, 0.4, 0.1, 0.1, 0 ],
                         [0.1, 0.3, 0.3, 0.2, 0.1],
                         [0.3, 0.2, 0.2, 0.2, 0.1],
                         [0.1, 0.3, 0.5, 0.1, 0],
                         [0.2, 0.3, 0.3, 0.1, 0.1],
                         [0.2, 0.3, 0.35, 0.15, 0],
                         [0.1, 0.3, 0.4, 0.1, 0.1],
                         [0.1, 0.4, 0.3, 0.1, 0.1],
                         [0.3, 0.4, 0.2, 0.1, 0],
                         [0.1, 0.4, 0.3, 0.1, 0.1],
                         [0.2, 0.3, 0.4, 0.1, 0],
                         [0.4, 0.3, 0.2, 0.1, 0]])

    m, n = eval_mat.shape

    separation_points = [0, 4, 9, 14]

    # TODO: 输入每个一级属性各二级属性的权重
    w_mat = np.array([[0.2, 0.3, 0.3, 0.2],
                      [0.3, 0.2, 0.1, 0.2, 0.2],
                      [0.1, 0.2, 0.3, 0.2, 0.2],
                      [0.3, 0.2, 0.2, 0.3]], dtype=object)
    # TODO: 输入每个一级属性权重
    w_vec = np.array([0.4, 0.3, 0.2, 0.1])

    #计算一级评判向量和二级评判矩阵
    separation_points.append(m)
    eval_mat_second = []
    for i in range(len(separation_points)-1):
        eval_mat_second.append(w_mat[i] @ eval_mat[separation_points[i]:separation_points[i+1], :])
    eval_mat_second = np.array(eval_mat_second)
    print(f"The second-level evaluation vectors are:\n {eval_mat_second}")
    #计算二级评判向量

    eval_vec = w_vec @ eval_mat_second
    print(f"The first-level evaluation vector is:\n {eval_vec}")

if __name__ == "__main__":
    fuzzy_evaluation()
```


## 应用

用模糊综合评价的套路：

Step1：解决评价类问题

Step2：确定因素集（如果因素过多可考虑用多级，可以用主成分分析法，后面会讲）确定各因素权重，注意每一级权重之和为1

Step3：确定评语集（有无评价色彩）

Step4：从最后一层开始逐级确定每级因素对评语集的隶属度 （逐级打分）

Step5：根据隶属度确定相关评语（注意画图）

一些小妙招

1.确定各因素权重是一个头疼的问题，这里给出一些建议：

对于给定题目或课题中有数据的，直接用熵权法的TOPSIS（有些教材也称为变异系数法，后面合讲）；对于没有数据的，可以用层次分析法（过程简写，主次分明），然后在论文里写上一句“根据专家意见”即可。

2.模糊综合评价原理并不难，只是各种模糊数学、矩阵向量这些形式比较唬人，其实真正拉开差距的点在于模型选取的合理与否（例如因素集的选取），另外，对于这种“没啥技术含量”的模型，可以用图文并茂的方法充实文章。

![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20241229104831.png)


![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20241229104800.png)


# 熵权法（变异系数法）

## 概论

熵权法（Entropy Weight Method）是一种基于信息熵理论的多指标决策方法，主要用于确定各评价指标在综合评价中的权重。该方法考虑了各指标的信息含量和变异程度，从而有效反映了指标的重要性。熵权法常与其他多标准决策方法结合使用，提升决策的科学性与合理性。下面是对熵权法的详细介绍。

### 1. 概述

熵权法：是一种可以对多对象、多指标进行综合评价的方法,其评价依据来源于数据本身，几乎不受主观因素的干扰。它的基本思想是：信息熵小→得到的信息少，掌握的信息多→这组信息更靠谱→权重大。

熵权法通过分析评价指标的变异程度，来赋予每个指标一个相应的权重。变异程度越大，说明该指标对评价结果的贡献越大，从而其权重也应相应增大。该方法在处理多指标评价时具有较好的客观性和系统性。
### 2. 基本原理
熵是信息论中的一个重要概念，用于衡量不确定性或信息量。在多指标评价中，指标的熵值可以反映其提供的信息量。熵值越小，说明指标的变动范围小，提供的信息量少；反之，熵值越大，则说明指标的变动范围大，提供的信息量多。

信息熵本质上是信息量的期望值，信息量的期望值最大，反映已掌握的信息量最少。

和层次分析法区别：熵权法是客观地决定权重，而层次分析法是主观地决定权重。

### 3. 熵权法步骤
熵权法通常可以分为以下几个步骤：

#### 3.1 确定指标体系
- 确定评价对象及目标。
- 建立多层次的指标体系，选择合适的评价指标。

#### 3.2 数据标准化
由于不同的指标可能具有不同的量纲和数值范围，因此需要对原始数据进行标准化处理。常用的标准化方法有：
- **极大值标准化**：将指标值转换为0到1之间的值：
  $x_{ij}' = \frac{x_{ij} - x_{\min}}{x_{\max} - x_{\min}}$
- **Z-score标准化**：根据均值和标准差进行标准化：
  $x_{ij}' = \frac{x_{ij} - \bar{x_j}}{\sigma_j}$

#### 3.3 计算熵值
1. **计算各指标的信息熵**：
   对于每个指标 $j$，计算其熵值 $E_j$：
   $E_j = -k \sum_{i=1}^{n} p_{ij} \ln(p_{ij})$
   其中，$p_{ij}$ 为指标 $j$ 在第 $i$ 个样本上的相对比重，$k$ 是一个常数，通常为 $k = \frac{1}{\ln(n)}$。

2. **计算熵权**：
   指标 $j$ 的权重 $w_j$ 由其熵值计算得出：
   $w_j = \frac{1 - E_j}{\sum_{j=1}^{m} (1 - E_j)}$
   其中，$m$ 为指标个数。

#### 3.4 综合评价
利用加权求和法或其他方法将各指标值与其权重结合，得出综合评价结果。

### 4. 优点
- **客观性强**：权重的确定不依赖于个人主观判断，而是基于指标的数据特性。
- **有效反映信息量**：通过熵值体现每个指标的信息贡献，能够更合理地划分权重。
- **适应性广**：可用于多种类型的决策问题，兼容性好。

### 5. 缺点
- **数据要求高**：对于数据的完整性、准确性和有效性要求较高。
- **计算复杂性**：在处理大规模指标体系时，计算过程较为复杂，需要一定的运算能力。
- **信息过于依赖**：在极端情况下，如果某些指标的数据过于集中，可能导致熵值偏小，影响权重的分配。

### 6. 应用领域
熵权法广泛应用于多个领域，包括：
- 环境评价
- 社会经济指标分析
- 产品质量评价
- 人力资源管理
- 教育绩效评价



## 指标处理

对于收入是越大越好，这样的指标称为极大型指标（效益型指标）；可对于年龄则是越小越好，这样的指标称为极小型指标 （成本型指标）。

第一步：正向化处理

类型|特点|举例
-|-|-
极大型/效益型指标|数值越大越好|就业率、GDP、收入
极小型/成本型指标|数值越小越好|负债率、恩格尔系数
中间型指标|越接近某个值越好|黄金比例、满座率、水质pH值
区间型指标|落在某个区间最好|贫富差距、出生率

正向化的方法并不唯一，选择合适的即可，只要能转成极大型都可以

极小型转极大型：例如前面统计的失业率,这个数值应该是越小越好,所以可以用$max-x$,或者$\frac{1}{x}(x>0)$

$\begin{aligned} & \text{中间型转极大型:数值不要太大也不要太小,越接近某个值越好,如}\left\{x_i\right\}\text{是一组中间型指标序列},\text{且最佳的数值为}x_{\mathrm{best~}}, \\ & \text{那么可以这样正向化:} \\ & \text{先取这个序列中最大差距值}M=\max\{|x_i-x_{\mathrm{best~}}|\},\quad\text{再令各元素}\tilde{x}_i=1-\frac{|x_i-x_{\mathrm{best~}}|}{M} \end{aligned}$

第二步：标准化处理

## 熵权法——Python代码实现

将给定的 MATLAB 代码转换为 Python 代码涉及几个步骤：数据读取、正向化、标准化和熵权计算.下面是详细的 Python 代码实现，全部代码使用了 `numpy` 和 `pandas` 库，并用 `openpyxl` 库处理 Excel 文件.

确保你在运行之前安装了这些库，如果未安装，可以通过以下方式安装：
```bash
pip install numpy pandas openpyxl
```

相关Excel表格内容如下所示：

|     | 年龄  | 身高  | 长相  | 学历(成绩) | 收入    |
| --- | --- | --- | --- | ------ | ----- |
| 大师兄 | 24  | 180 | 60  | 90     | 5000  |
| 小A  | 23  | 175 | 90  | 85     | 10000 |
| 小B  | 23  | 170 | 95  | 92     | 8000  |
| 小C  | 24  | 185 | 81  | 100    | 5500  |
| 小D  | 25  | 190 | 79  | 60     | 2000  |

接下来的 Python 代码逐步解析了 MATLAB 代码中的每一个部分，同时保留了逻辑结构：

```python
import numpy as np  
import pandas as pd  
import matplotlib.pyplot as plt  
# 从 Excel 文件中读取数据  
X = pd.read_excel('blind date.xlsx', skiprows=[0], usecols="B:F", header=None)  
print(X.columns)  
print(X.head())  
  
X = X.to_numpy()  
X = X.astype(float)  # 确保数据为浮点类型  
  
  
# 正向化函数  
def Min2Max(column):  
    M = np.max(column) - np.min(column)  # 计算范围  
    return (np.max(column) - column) / M  # 归一化到 0-1  
  
def Mid2Max(column, best):  
    M = np.max(np.abs(column - best))  # 计算最大距离  
    return 1 - np.abs(column - best) / M  # 距离归一化  
  
  
def Int2Max(column, a, b):  
    M = np.max([a - np.min(column), np.max(column) - b])  # 计算最大范围  
    res = np.zeros_like(column)  # 初始化结果数组  
    for i, x in enumerate(column):  # 遍历每个元素  
        if x < a:  
            res[i] = 1 - (a - x) / M  # 小于下界  
        elif a <= x <= b:  
            res[i] = 1  # 在范围内  
        else:  
            res[i] = 1 - (x - b) / M  # 大于上界  
    return res  

# 正向化处理  
print('***************正在进行正向化...***************')  
vec = input('请输入要正向化的向量组，请以数组的形式输入，如[1, 2, 3]表示1，2，3列需要正向化，不需要正向化请输入-1\n')  
if vec != '-1':  
    vec = list(map(int, vec.strip('[]').split(',')))  
  
    for i in vec:  
        flag = int(input(f'第{i}列是哪类数据(【1】:极小型 【2】：中间型 【3】：区间型)，请输入序号：\n'))  
  
        # 增加数据检查步验证和打印调试信息  
        column = X[:, i - 1]  # 提取该列  
        print(f'column type: {type(column)}, column shape: {column.shape}')  # 打印列类型和形状  
  
        if flag == 1:  # 极小型  
            X[:, i - 1] = Min2Max(column)  
        elif flag == 2:  # 中间型  
            best = float(input('请输入中间型的最好值：\n'))  
            X[:, i - 1] = Mid2Max(column, best)  
        elif flag == 3:  # 区间型  
            arr = input('请输入最佳区间，按照“[a,b]”的形式输入：\n')  
            a, b = map(float, arr.strip('[]').split(','))  
            X[:, i - 1] = Int2Max(column, a, b)  
  
    print('所有的数据均已完成正向化！')  
  
    # 绘图每一列的正向化结果  
    plt.figure(figsize=(10, 6))  
    colors = ['r', 'g', 'b', 'c', 'm']  # 使用不同的颜色  
    for index in range(len(vec)):  # 绘制所有正向化后的列  
        plt.plot(X[:, index], color=colors[index % len(colors)], label=f'Column {vec[index]}')  
    plt.title('Normalized Data Plot')  
    plt.xlabel('Sample Index')  
    plt.ylabel('Normalized Values')  
    plt.legend()  
    plt.grid()  
    plt.show()  
  
# 标准化处理  
print('***************正在进行标准化...***************')  
n, m = X.shape  
  
# 判断是否有负数元素  
isNeg = np.any(X < 0)  
if not isNeg:  
    square_X = X ** 2  
    sum_X = np.sqrt(np.sum(square_X, axis=0))  
    stand_X = X / sum_X  
else:  
    max_X = np.max(X, axis=0)  
    min_X = np.min(X, axis=0)  
    stand_X = (X - min_X) / (max_X - min_X)  
  
print('标准化完成！')  
  
# 计算样本概率、信息熵和熵权  
print('***************正在用熵权法确定权值...***************')  
P = stand_X / np.sum(stand_X, axis=0)  
P[P == 0] = 0.00001  # 替换概率为0的元素  
  
  
  
  
H_x = np.sum(-P * np.log(P), axis=0)  # 计算信息熵  
e_j = H_x / np.log(n)  # 熵  
d_j = 1 - e_j  # 计算熵权  
  
# 归一化  
w = d_j / np.sum(d_j)  # 最终权重值  
print('熵权完成，权值为：', w)
```

代码说明
1. **数据读取**: 使用 `pandas` 的 `read_excel` 函数读取 Excel 文件，并将数据转换为 NumPy 数组.
2. **正向化**:
   - 包含三个函数 `Min2Max`, `Mid2Max`, 和 `Int2Max` 实现不同类型的数据正向化.
   - `input` 函数获取用户输入，进行正向化操作.
3. **标准化**:
   - 判断是否存在负数，决定使用不同的标准化方法.
   - 这里使用了 NumPy 的 array 操作来进行快速计算.
4. **熵权法**:
   - 根据提供的公式计算样本概率和相应的熵值.
   - 处理概率为0的情况防止取对数时出现错误.
   - 计算熵权并进行归一化.


输入输出过程：

```
Index([1, 2, 3, 4, 5], dtype='int64')
    1    2   3    4      5
0  24  180  60   90   5000
1  23  175  90   85  10000
2  23  170  95   92   8000
3  24  185  81  100   5500
4  25  190  79   60   2000
***************正在进行正向化...***************
请输入要正向化的向量组，请以数组的形式输入，如[1, 2, 3]表示1，2，3列需要正向化，不需要正向化请输入-1
[1,2,3]
第1列是哪类数据(【1】:极小型 【2】：中间型 【3】：区间型)，请输入序号：
1
column type: <class 'numpy.ndarray'>, column shape: (5,)
第2列是哪类数据(【1】:极小型 【2】：中间型 【3】：区间型)，请输入序号：
2
column type: <class 'numpy.ndarray'>, column shape: (5,)
请输入中间型的最好值：
180
第3列是哪类数据(【1】:极小型 【2】：中间型 【3】：区间型)，请输入序号：
3
column type: <class 'numpy.ndarray'>, column shape: (5,)
请输入最佳区间，按照“[a,b]”的形式输入：
[80,90]
所有的数据均已完成正向化！
***************正在进行标准化...***************
标准化完成！
***************正在用熵权法确定权值...***************
熵权完成，权值为： [0.23286325 0.47418967 0.19110087 0.01125884 0.09058738]
```

## 结论
熵权法是一种科学、合理的多指标决策和评价方法，能够客观地反映各评价指标的重要性与信息贡献。在具体应用中，合理选择指标和合适的数据处理方法将有助于提高评价的准确性与有效性。

# TOPSIS

TOPSIS方法（Technique for Order Preference by Similarity to Ideal Solution）是多属性决策分析中的一种常用方法，由Hwang和Yoon在1981年提出。该方法的基本思想是通过计算各替代方案与理想解和反理想解之间的距离，来确定各方案的优先级。

## 1. 方法概述
TOPSIS方法基于以下假设：
- 每个决策方案都有一个理想解和一个反理想解。
- 理想解是性能最好的方案，反理想解是性能最差的方案。
- 最佳方案应与理想解的距离最小，而与反理想解的距离最大。

## 2. TOPSIS的基本步骤

### 2.1 确定决策矩阵
设有 $m$ 个替代方案和 $n$ 个评价指标，可以用决策矩阵表示为：

$$
D = 
\begin{bmatrix}
x_{11} & x_{12} & \cdots & x_{1n} \\
x_{21} & x_{22} & \cdots & x_{2n} \\
\vdots & \vdots & \ddots & \vdots \\
x_{m1} & x_{m2} & \cdots & x_{mn}
\end{bmatrix}
$$

其中 $x_{ij}$ 表示第 $i$ 个方案在第 $j$ 个指标下的得分。

### 2.2 数据标准化
为了消除不同指标之间的量纲差异，需要对决策矩阵进行标准化。标准化后得出的矩阵为 $Z = (z_{ij})$，其计算公式为：

对于收益型指标：

$$
z_{ij} = \frac{x_{ij}}{\sqrt{\sum_{i=1}^{m} x_{ij}^2}} \quad (j = 1, 2, \ldots, n)
$$

对于成本型指标：

$$
z_{ij} = \frac{\min_{i} x_{ij}}{x_{ij}} \quad (j = 1, 2, \ldots, n)
$$

### 2.3 计算加权标准化决策矩阵
设定每个指标的权重为 $w_j$，加权标准化决策矩阵 $V = (v_{ij})$ 可以表示为：

$$
v_{ij} = w_j \cdot z_{ij} \quad (j = 1, 2, \ldots, n)
$$

### 2.4 确定理想解和反理想解
- 理想解 $A^+$ 和反理想解 $A^-$ 分别为加权标准化决策矩阵中每个指标的最优值和最差值：

$$
A^+ = \left( \max_{i} v_{ij} \right) \quad (j = 1, 2, \ldots, n)
$$

$$
A^- = \left( \min_{i} v_{ij} \right) \quad (j = 1, 2, \ldots, n)
$$

### 2.5 计算各方案与理想解和反理想解的距离
- 各方案与理想解的距离 $D_i^+$ 和与反理想解的距离 $D_i^-$ 计算公式如下：

$$
D_i^+ = \sqrt{\sum_{j=1}^{n} (v_{ij} - A^+_j)^2}
$$

$$
D_i^- = \sqrt{\sum_{j=1}^{n} (v_{ij} - A^-_j)^2}
$$

### 2.6 计算相对接近度
最后，计算每个方案的相对接近度 $C_i$，用以衡量方案与理想解的相似度：

$$
C_i = \frac{D_i^-}{D_i^+ + D_i^-} \quad (i = 1, 2, \ldots, m)
$$

### 归一化、距离法和标准化的区别与联系

- 距离法和标准化都能使结果落到`[0,1]`区间，但是不能让和为1
- 用距离法时要确定最大值和最小值，可是有很多指标不存在理论上的最大值和最小值，例如衡量经济增长水平的GDP增速，所以选取给定数据中的最值即可
- 标准化是为了消除不同量纲的影响
- 距离法的几何意义是每个值所占的线段比例
- 归一化不仅能将结果划到`[0,1]`区间，还能使和为1


正向化处理——将所有的指标转化为极大型，转换公式$max-x$

标准化处理——因为单位不同，所以要消除量纲的影响需要进行标准化处理

归一化处理——$评分=\frac{x-min}{max-min}$

可以使用距离法打分或优劣解打分。

## 3. 结果排序
根据计算出的接近度 $C_i$，对所有方案进行排序，$C_i$ 值越大，说明该方案越接近理想解，优先级越高。最终根据相对接近度进行决策。

## 4. TOPSIS方法的优点与缺点

#### 4.1 优点
- 简单直观：使用过程简单，易于理解和实现。
- 可确定性强：提供具体的数值来辅助决策。
- 适用范围广：可以应用于多种决策问题。

#### 4.2 缺点
- 权重的影响：权重的确定在一定程度上是主观的。
- 对于距离的敏感性：方案间的距离可能受到指标值分布的影响。

## 5. 结论
TOPSIS方法是一种有效的多属性决策分析工具，特别适用于处理有多个评价指标的决策问题。通过理想解与非理想解之间的距离比较，能帮助决策者做出更为理性的选择。该方法可结合其他决策工具使用，增强决策结果的合理性和科学性。

## TOPSIS之Python实现

```python
import numpy as np

# 假设stand_X是前面的Python代码得到的结果
# n 和 m 定义为行数和列数
n, m = stand_X.shape

# （法一）用距离法打分
print('***************正在用距离法打分...***************')
max_x = np.max(stand_X, axis=0)  # 按照列找出最大元素
min_x = np.min(stand_X, axis=0)  # 按照列找出最小元素

# 计算标准化后的评分
normalized_score_distance = (stand_X - min_x) / (max_x - min_x)

# （法二）用优劣解打分
print('***************正在用优劣解打分...***************')

tmp = np.ones((m, m))  # 创建一个全1的矩阵
w_j = tmp[:, 0]  # 初始化权重为第一列的全1数组

is_need_w = int(input('是否需要指定权值，如需要请输入1，否则请输入0:\n'))
if is_need_w == 1:
    w_j = np.array(eval(input('请按列输入各指标的权值：(如[0.1,0.2,0.3,0.4])')))
    
Z_plus = np.tile(max_x, (n, 1))  # 构建目标改善解
Z_sub = np.tile(min_x, (n, 1))   # 构建目标劣化解

D_plus = np.sqrt(np.sum(((stand_X - Z_plus) ** 2) * w_j, axis=1))  # 按行求和
D_sub = np.sqrt(np.sum((stand_X - Z_sub) ** 2 * w_j, axis=1))

S = D_sub / (D_sub + D_plus)  # 计算综合得分

# 将结果归一化
res_topsis = S / np.sum(S)

# 保存结果到Excel
# 使用pandas库将结果输出到Excel.如果没有安装pandas，请使用pip install pandas.
import pandas as pd
pd.DataFrame(res_topsis).to_excel('res_topsis.xlsx', index=False, header=False)

print('已完成打分，请到当前目录下res_topsis.xlsx文件中取出结果！')
```

代码讲解：
1. **数据输入和处理**：
   - 假设 `stand_X` 是从之前的Python代码得到的标准化结果，形状为 `(n, m)`.
   - `max_x` 和 `min_x` 分别对应于每列的最大值和最小值.

2. **评分方式**：
   - 距离法通过 `max_x` 和 `min_x` 生成归一化评分.
   - 优劣解方法需要用户输入权重，若选择不指定，则使用默认值.

3. **计算距离**：
   - 计算理想解 `Z_plus` 和 `Z_sub` 使用 `np.tile()`，以构建与 `stand_X` 相同形状的数组.
   - 距离的计算使用平方和开根号，符合原始Matlab逻辑.

4. **归一化**：
   - 最后，将结果归一化，并用 `pandas` 保存结果到Excel文件中.

对应的MatLab代码如下所示：

```matlab
%% （法一）用距离法打分
disp('***************正在用距离法打分...***************');
max_x = max(stand_X,[], 1) %按照列找出最大元素
min_x = min(stand_X,[], 1) %按照列找出最小元素

(stand_X - repmat(min_x,n,1)) ./ (max_x - min_x)


%% （法二）用优劣解打分
disp('***************正在用优劣解打分...***************');
tmp = ones(m);% 这个矩阵很有用，要掌握哦
w_j = tmp(:,1);
is_need_w = input('是否需要指定权值，如需要请输入1，否则请输入0:\n');
if (is_need_w == 1)
    w_j = input('请按列输入各指标的权值：(如[0.1;0.2;0.3;0.4])')
end
Z_plus = repmat(max_x,n,1);
Z_sub = repmat(min_x,n,1);
D_plus = sum(((stand_X - Z_plus).^2) * w_j, 2).^0.5 %注意是按行求和
D_sub = sum(((stand_X - Z_sub)).^2 * w_j, 2).^0.5

S = D_sub ./ (D_sub + D_plus)

%将结果归一化
res_topsis = S ./ sum(S)
%xlswrite('res_topsis.xlsx',res_topsis) %写入excel文档
%disp('已完成打分，请到当前目录下res_topsis.xlsx文件中取出结果！')
```







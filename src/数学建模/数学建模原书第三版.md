# A First Course in Mathematical Modeling

<!-- toc -->

# 前言

本书旨在指导学生初步掌握数学建模的思想和方法，共分两大部分：离散建模和连续建模。本书对于用到的数学知识力求深入浅出，涉及的应用领域相当广泛，适合作为高等院校相关专业的数学建模教材和参考书。也可作为参加国内外数学建模竞赛的指导用书。

数学建模（Mathematical Modeling）是用数学方法解决各种实际问题的桥梁，随着计算机的发明和计算机技术的飞速发展，数学的应用日益广泛，数学建模的作用越来越重要，而且已经渗透到各种领域，可以毫不夸张地说，数学和数学建模无处不在。甚至报刊中也越来越多地出现数学建模、建模和数学模型这样的术语（包括它们的英文名称Mathematical Modeling、Modeling和Mathematical Model），它们正在成为人们日常生活和语言交流中常见的术语。

本教材介绍完整的建模过程，学生有机会实践建模的以下各个方面并能增强解决问题的能力：

1 创造性和经验模型的构建：给定一种现实情景，学生要学习识别问题、做出假设和收集数据、提出模型、测试假设、必要时精炼模型，在情况适宜时看看模型和数据是否一致，以及分析模型的基本数学结构以评价当并不精确地满足假设时对结论的敏感性。
2 模型分析：给定一个模型，学生要学会反向推理以揭示那些不一定是显式表示的基本假设，审慎严谨地评估这些假设和手头要处理的情景相符合的程度，并估计当并不精确地满足假设时对结论的敏感性。
3 模型研究：研究一个特定的领域以获得对某些行为更深入的理解并学会使用早已创建或公诸于世的模型。

![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250102104145.png)

## 内容简介

《华章数学译丛：数学建模（原书第5版）》旨在指导学生初步掌握数学建模的思想和方法，共分两大部分：离散建模和连续建模，通过本书的学习，学生将有机会在创造性模型和经验模型的构建、模型分析以及模型研究方面进行实践，增强解决问题的能力。

《华章数学译丛：数学建模（原书第5版）》对于用到的数学知识力求深入浅出，涉及的应用领域相当广泛，适合作为高等院校相关专业的数学建模教材和参考书，也可作为参加国内外数学建模竞赛的指导用书。

## 作者简介

Frank R。Giordano，毕业于美国西点军校，曾任西点军校数学系系主任，现为美国海军研究生院教授，多年来一直是美国大学生数学建模竞赛的主要组织者，也是美国大学生数学建模竞赛组委会主任。


# 差分方程

对变化进行建模的一个非常有用的范例就是`未来值=现在值+变化`。

人们往往希望从现在知道的东西加上精心观测到的变化来预测未来。在这种情形中，可以先按照公式`变化=未来值-现在值`来研究变化。

通过收集一段时间中的数据并画出该数据的图形，我们常常可以识别出能够抓住这种变化趋势的模型的模式。如果这种行为是在离散时间段上发生的，那么前面的模型构建就导致本章要介绍的差分方程。如果行为在时间上是连续发生的，那么模型构建就导致了第10章要介绍的微分方程。这两者都是描述和预测行为变化的强有力的方法。

**差分方程**是描述离散时间系统中变量之间关系的方程，它用当前时刻和前一时刻（或多个时刻）的变量值来表示当前时刻的变量值。基本上，差分方程可以看作是连续动态系统的离散版本。

## 一、差分方程的基本形式

一般的差分方程可以写作：

$y(n) = f(y(n-1), y(n-2), \ldots, x(n))$

其中，$y(n)$ 是当前时刻的输出，$x(n)$ 是当前时刻的输入。

## 二、具体例子：线性差分方程

考虑一个简单的线性差分方程：

$y(n) = 0.5 y(n-1) + x(n)$

这里，$y(n)$ 表示当前时刻的输出，$y(n-1)$ 表示前一时刻的输出，$x(n)$ 是当前时刻的输入。

示例

假设输入序列 $x(n) = 1$（即在每个时刻都输入1），并且我们设定初始条件 $y(0) = 0$。

1。 **计算第1步**（n=1）：
   $y(1) = 0.5 \cdot y(0) + x(1) = 0.5 \cdot 0 + 1 = 1$

2。 **计算第2步**（n=2）：
   $y(2) = 0.5 \cdot y(1) + x(2) = 0.5 \cdot 1 + 1 = 1.5$

3。 **计算第3步**（n=3）：
   $y(3) = 0.5 \cdot y(2) + x(3) = 0.5 \cdot 1。5 + 1 = 1.75$

通过这个例子，我们可以看到如何用差分方程来描述时间序列数据的演变。差分方程在工程、经济学、生态学等多个领域都有广泛的应用。

## 应用

### 用差分方程对变化进行建模  

例1储蓄存单  

例2抵押贷款买房  

### 用差分方程近似描述变化  

例1酵母培养物的增长  

例2再论酵母培养物的增长  

例3接触性传染病的传播  

例4血流中地高辛的衰减  

例5冷冻物体的加热  

### 动力系统的解法  

例1再论储蓄存单  

例2污水处理  

例3地高辛处方  

例4投资年金  

例5活期储蓄账户  

例6再论投资年金  

### 差分方程组  

例1汽车租赁公司 

例2特拉法尔加战斗  

例3竞争猎兽模型——斑点猫头鹰和隼  

例4对政党的投票趋势

# 如何建模

## 建模过程、比例性和几何相似性  

### 数学模型的结构

第1步 识别问题

第2步做出假设

1. 识别变量并对变量进行分类
2. 确定变量和子模型之间的相互关系

第3步求解模型

第4步验证模型

1. 表述了问题吗？
2. 在通常的意义下它有意义吗? 
3. 用实际数据来检验该模型。

第5步实施模型

第6步维修模型

例子：车辆的停止距离

### 模型简化VS模型改进

模型简化：

1. 限制问题的识别
2. 忽略一些变量
3. 若干变量合并的效果
4. 令某些变量为常数
5. 假设简单的(线性)关系 
6. 融入更多的假设

模型改进：

1. 扩展问题
2. 考虑额外的变量
3. 仔细地考虑每个变量
4. 允许变量中的变化
5. 考虑非线性关系
6. 减少假设的数量

### 利用比例性进行建模

比例性关系对应的直线需要过原点，例如$F=ma$

例1开普勒第三定律  

### 利用几何相似性进行建模  

例1从不动的云层落下的雨滴  

例2钓鱼比赛中的建模  

汽车的汽油里程  

体重和身高、力量和灵活性  


## 模型拟合

区分拟合和插值

建模过程中的误差来源：

- 公式化的误差
- 截断误差
- 舍入误差
- 测量误差

### 用图形为数据拟合模型  

### 模型拟合的解析方法  

$\textbf{给 定 某 种 函 数 类 型  y= }f( x) \textbf{和  }m\textbf{ 个 数 据 点 }( x_i, y_i)$的一个集合，对整个集合极小化最大绝
对偏差$|y_i$一$y(x_i)|$,即确定函数类型 y$= f( x) \textbf{的 参 数 从 而 极 小 化 数 量 }$

$\mathbf{Maximum| y_i- f( x_i) | \:i= 1, 2, \cdots , m}$

这一重要的准则常称为 Chebyshev 近似准则。Chebyshev 准则的困难在于实际应用中通常很复杂，至少是仅用初等演算时很复杂。应用这一准则所产生的最优化问题可能需要高级的数学方法，或者要用计算机的数值算法。

我们将要看到，有另一准则能方便地解决最优化问题。“正是由于这-原因，在对有限的数据点拟合一条曲线时不常使用Chebyshev准则。 然而当极小化最大绝对偏差很重要的时候仍应考虑使用这一准则(在第7章考虑这一准则的几个应用)。进一步在用一函数代替一个区间上定义的另一个函数时，构成Chebyshev 准则的原则是极其重要的，在该区间上两个函数间的最大差异必须达到最小。逼近论研究这一论题，而且导论性的数值分析中都有这部分内容。

极小化绝对偏差之和：$\sum_{i=1}^m\mid y_i-f(x_i)\mid$

现在最常用的曲线拟合准则是最小二乘准则。使用与前面相同的记号，问题是确定函数类型 y=f(x)的参数，极小化和数

$\sum_{i=1}^m\mid y_i-f(x_i)\mid^2$

三个曲线拟合准则的几何解释有助于在量化描述方面比较准则。极小化绝对偏差和将赋予每一数据点相等的权值来平均这些偏差。Chebyshev准则对潜在有大偏差的单个点给予更大的权值。最小二乘准则是根据与中间某处的远近来加权，其权与单个点具有的显著偏离有关。由于解析地运用Chebyshev和最小二乘准则更方便些，我们现在寻求一个方法来谈谈用这两个准则产生的偏差。

### 应用最小二乘准则  

拟合直线

拟合幂曲线

经变换的最小二乘拟合

### 选择一个好模型  

例1车辆的停止距离  

## 实验建模  

### Chesapeake海湾的收成和其他的单项模型  

例1收获蓝鱼  

例2收获蓝蟹  

### 高阶多项式模型  

例1带式录音机的播放时间  

多项式的Lagrange形式

高阶多项式的优点和缺点

### 光滑化：低阶多项式模型  

我们寻找一些保留了高阶多项式的优点而摒弃了其缺点的方法，一个通用的技术是选取一个低阶多项式，而不管数据的个数。这样的选择正常情况下会产生一种状况，即，数据点的数目会超过确定多项式所需系数的个数。由于要确定的常数比数据点少，低阶多项式通常不通过全部数据点。例如：决定对一个10个数据点的集合拟合一个二次式，因为通常不可能将一个二次形通过10个数据点，必须决定哪一个二次形最佳拟合了数据（根据第3章讨论的某一准则），这一过程称为光滑化。使用低阶多项式，同时不要求它通过每一数据点，合在一起将降低多项式摆动的倾向，以及它对数据中微小变化的敏感性，因为不要求通过全部数据点，这一个二次函数实现了数据光滑化。

光滑化的过程要求做出两个决定。第一必须选定插值多项式的阶。第二根据某一准则确定最佳拟合多项式的系数。这就产生了第3章讨论的形式的优化问题。例如：可以决定对10个数据点拟合一个二次式模型，使用最小二乘最佳拟合准则。我们将回顾用最小二乘准则对数据集拟合一个多项式的过程，然后再转到更困难的问题：如何最好地选择插值多项式的阶。

例1再论带式录音机的播放时间  

例2再论带式录音机的播放时间  

差分$y_{i+1} - y_{i} = \Delta y$

尽管数据的特征基本上是二次形，由于数据收集过程及建模中的各种误差，我们不应期望差分
准确地为零，然而可以期望数值变得很小，可以计算均差以改进对所谓“小"的评判。

![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250113095349.png)

历史上，均差表用于确定内插多项式的各种形式，使得多项式通过一个选定的数据点的子集。今天，光滑化和三阶样条等其他内插技术更为通用。虽然如此，计算差分表是容易的，它们与其所近似的导数一样，很方便地提供了一个有用的数据信息源。

例3车辆的停止距离  

例4酵母培养物的增长  

### 三阶样条模型  

由于多项式容易积分和微分，构造经验模型追踪数据的趋势时，常使用多项式。然而，高阶多项式在邻近数据区间的端点处有摆动的倾向，且系数对数据中小的变化太敏感。除非数据的特征基本上是二次或三次式，用低阶多项式来光滑化，可能在数据范围的某些地方拟合相当差。例如，在4。3节车辆刹车距离问题中，当速度很快时，用二次式模型拟合的效果，就不是很好。

在这一节，引进一项非常通用的建模技术，称为三阶样条插值，在连续的数据点对间使用不同的三阶多项式，追踪数据的趋势，既保证基本关系的特征，同时减少摆动的倾向和数据变化的灵敏性。

例1再论车辆的停止距离  

## 模拟方法建模  

在许多情况下，由于对象过于复杂或提出的解释性模型难以处理，建模者无法得到一个能够充分说明对象行为的分析（符号）模型，而当必须对对象的行为做出预报时，建模者可以进行实验(或收集数据)来研究在某个范围内因变量与自变量的选择值之间的关系。在第 4章我们基于收集的数据建立了经验模型。为了收集数据建模者可以直接观测对象的行为，在另外一些情况中，对象的行为应能够在可控制的条件下重现(可能以按比例缩放的形式)，如 8。4节所讨论的预测爆破物形成的弹坑的大小。

在某些情况下，对对象的行为进行直接观测或重复试验可能是不可行的，例如早高峰时电梯系统提供的服务。在明确了--个合适的问题及确定了什么是好的服务之后，我们可以提出若干供选择的电梯运行模式，如设定停偶数层、奇数层的电梯或直达电梯。理论上，对每种供选择的模式都能够做若干次试验，以确定哪一种模式能为那些要到达特定楼层的乘客提供最好的服务，然而这种做法可能是难以接受的，因为在收集统计数据时要再三惊扰乘客，并且电梯运行模式的不断变化也会使乘客感到迷惑。与此有关的另一个问题是大城市交通控制系统可供选择的运行模式的检验，为了做试验而不停地改变单行道的交通方向和配置交通信号将是不现实的。

还有另一些情况，需要对可供选择的模式做试验的系统甚至可以不存在。例如，对于一座办公大楼，要确定几个通讯网络中哪一个最好。又如，确定一个新工厂的各台机器的布局。进行试验的费用可能是很高的，当核电站发生事故时，为防护和疏散居民而预测各种方案的影响所做的试验就是这种情况。

在对象的行为不能做分析性的解释，或数据无法直接收集的情况下，建模者可以用某种方式间接地模拟其行为，试验所研究的供选择的各种方案，以估计它们怎样影响对象的行为，然后收集数据来确定哪种方案是最好的。 例如，为了得到一艘拟建造的潜艇受到的阻力，造一个原型是不可行的，我们可以按比例建一个模型，去模拟实际的潜艇的行为。又如，在风洞里利用喷气飞机的比例模型可以估计高速飞行对飞机各种设计方案的影响。本章还将研究另外一种形式的模拟，称为蒙特卡罗（Monte Carlo)模拟，它一般是借助于计算机完成的。

假如我们要研究早高峰时一组电梯提供的服务，做蒙特卡罗模拟时，乘客在这段时间内到达电梯和他们选择去的楼层都需要重现，这就是说，模拟中乘客到达时刻的分布和去的楼层的分布都应是一个早高蜂的实际情况的描述，而在模拟了多次之后，所发生的那个到达时刻和去的楼层的分布就应该适当地反映了现实生活中的分布。在对这种重现感到满意之后，我们就可以研究电梯的各种运行策略。通过大量的试验可以收集统计数据，如平均每位乘客的总的运送时间、最长等候队伍的长度，这些数据能够帮助确定电梯运行的最好策略。

本章只是蒙特卡罗模拟的简明介绍，深人研究计算机模拟及其应用需要更多的概率统计知识，不过你将了解数学建模这个有力工具。要记住，对于根据模拟结果的预测寄予太多的信任是有危险的，特别是在模拟中包含的假设没有清楚表明的时候。还有，由于用了大量的数据和庞大的计算，再加上非专业人员理解模拟模型和计算机输出相对容易，所以常会导致对模拟结果的过分相信。

做任何的蒙特卡罗模拟，都要用到随机数，我们在5。2节介绍如何产生随机数。不太严格地说，一个“在m 到n区间中均匀分布的随机数序列"是一组没有明显模式的数，m和n之间的每个数都以相同的可能性出现。例如，一颗骰子掷100次，记下每次骰子出现的点数，就会得到在1到 6 区间上近似于均匀分布的 100 个随机整数序列，于是得到了由 6个数字组成的随机数。抛一枚硬币可以用产生随机数来模拟，随机数为偶数定义为正面向上，随机数为奇数定义为反面向上。如果抛很多次，正面向上的次数会在50%左右，但是这里存在着偶然因素。 抛100次得到 51个正面，并且接下来的 10次（即使不太可能刚巧 10次)全为正面的情况是可能出现的，这样，用110次的结果进行估计实际上比用100次要差。与确定的过程相反，带有偶然因素的过程称为随机的，因此蒙特卡罗模拟是一种随机模型。

建模对象的行为可以是确定的或随机的，如一条曲线下的面积是确定的（虽然不能精确地得到)，而某一天乘客到达电梯的时间间隔是随机的。一个确定性模型可以用于近似确定的或随机的行为，同样，蒙特卡罗模拟也可以用于近似确定的（如将会看到的曲线下面积的蒙特卡罗逼近)或随机的行为，如图5-1所示。然而正如我们所期望的，蒙特卡罗模拟的真正威力在于对随即行为的建模。

蒙特卡罗模拟的一个主要优点是，它有时能相对容易地近似很复杂的随机系统，并且，与分析模型的应用范围常常受限制相比，蒙特卡罗模拟可以在更广泛的条件下估计候选方案的性能。还有，因为在蒙特卡罗模拟中特定的子模型可以相当容易地改变（如乘客到达和离开电梯的模式），所以存在着进行敏感性分析的潜力。蒙特卡罗模拟的另一个优点是，建模者可以在不同层次的水平上进行控制，例如，很长的时间框架能够压缩，短的时间框架能够延伸，从而比经验模型更加优越。最后，现在有许多很有效的、高水平的模拟语言（如GPSS，GASP， PROLOG，SIMAN，SLAM 和 DYNAMO)，在建立模拟模型时能够排除掉许多繁琐的工作。

从负面看，建立和运行模拟模型相当昂贵，要用很多时间去构造，也要用很多的计算机时间和内存去运行。另外，模拟模型的随机性使得从一次特定试验中得到的结论受到限制，除非进行了敏感性分析，而即使只考虑少量的、在各种子模型中可能出现的条件组合，这样的分析也常常需要做很多次试验，所以这种限制迫使建模者要去估计在一组特定的条件组合中哪一个组合可能会出现。

### 确定行为的模拟：曲线下的面积  

每张彩票按照以下方式“藏"着一个数：55%的彩票藏着1，35%的彩票藏着2，10%的彩票藏着3。得到所有3个数的彩票购买者获得奖金。设计一个试验，确定买多少张彩票才能获得奖金。

要解决这个问题，我们可以使用蒙特卡洛模拟来估算需要购买多少张彩票才能获得奖金。我们的目标是找出在多次实验中买多少张彩票可以确保获得奖金。根据题目的描述，每张彩票的“藏着”数值的分布如下：

- 55% 的彩票藏着 1
- 35% 的彩票藏着 2
- 10% 的彩票藏着 3

蒙特卡洛模拟步骤

1 **定义分布**：根据概率分布定义每张彩票可能藏着的数值。

2 **进行模拟**：模拟买多张彩票，记录每次购买的结果和总和。

3 **检查是否获奖**：判断购买的彩票的总和是否达到奖金条件（即有至少一个彩票藏着3，否则是中奖）。

4 **统计结果**：记录购买的票数并进行多次模拟，以便计算在什么样的购买彩票数上可以达到目标概率（例如，95% 的实验中获奖）。

5 **估算所需彩票数量**：通过实验结果找到满足条件的最小票数。

下面是用 Python 实现的蒙特卡洛模拟代码：

```python
import numpy as np

def simulate_lottery(num_tickets):
    # 定义彩票的数值分布
    probabilities = [0.55, 0.35, 0.10]  # 概率
    values = [1, 2, 3]                  # 对应的值
    # 随机生成彩票的结果
    tickets = np.random.choice(values, size=num_tickets, p=probabilities)
    return tickets

def monte_carlo_lottery(trials, max_tickets):
    successful_counts = []

    for num_tickets in range(1, max_tickets + 1):
        successes = 0
        
        for _ in range(trials):
            tickets = simulate_lottery(num_tickets)
            # 检查是否有藏着3的票
            if 3 in tickets:
                successes += 1

        # 计算成功的比例
        successful_counts.append(successes / trials)

    return successful_counts

# 参数设置
trials = 10000     # 每个购买彩票数的模拟次数
max_tickets = 50   # 最大购买彩票数量（可以调整）

success_rates = monte_carlo_lottery(trials, max_tickets)

# 输出结果
for num_tickets, success_rate in enumerate(success_rates, start=1):
    print(f"Buying {num_tickets} tickets: {success_rate * 100:.2f}% success rate")

# 可视化成功率（可选）
import matplotlib.pyplot as plt

plt.plot(range(1, max_tickets + 1), success_rates, marker='o')
plt.xlabel('Number of Tickets')
plt.ylabel('Success Rate (%)')
plt.title('Lottery Success Rate vs Number of Tickets')
plt.axhline(y=0。95*100, color='r', linestyle='--', label='95% Success Rate Threshold')
plt.legend()
plt.grid()
plt.show()

```

代码解释

1 **`simulate_lottery` 函数**：该函数根据定义好的概率生成购买的彩票结果。

2 **`monte_carlo_lottery` 函数**：模拟不同数量的彩票购买，记录在直到 `max_tickets` 时成功获奖的次数。

3 **成功率计算**：对每个票数计算成功的比例，并记录成功率。

4 **输出与可视化**：输出每个购买彩票数量的成功率，并可选择绘制成功率图，帮助分析需要多少张彩票才能达到目标成功率（比如 95%）。

结论

通过这种方法，你可以找到在这个彩票游戏中，买多少张彩票可以确保有相应的成功率取决于设定的目标值。你可以通过调整 `max_tickets` 和 `trials` 的数量来得到更精确的结果。


用蒙特卡罗模拟写出一个算法，计算椭球
$$\frac{x^2}2+\frac{y^2}4+\frac{z^2}8\leqslant16$$

在第 1 卦限( $x> 0, y> 0, z> 0) \textbf{的 体 积 }。$

要使用蒙特卡罗模拟计算给定椭球在第一卦限（$x > 0, y > 0, z > 0$）内的体积，我们可以遵循以下步骤：

1 **定义椭球方程**：椭球的方程为 $$\frac{x^2}{2} + \frac{y^2}{4} + \frac{z^2}{8} \leq 16$$。

2 **确定随机采样范围**：在第一卦限内，$x$, $y$, $z$ 的值在 $[0, \sqrt{32}]$ （这个值是从椭球方程得出的，比如对于 $x$，当 $y=z=0$时，$x^2 / 2 \leq 16$，即 $x^2 \leq 32$）。

3 **生成随机点**：在上述范围内生成许多随机点。

4 **检查每个点是否在椭球内**：对于生成的每个随机点 $(x, y, z)$，检查其是否满足椭球的方程。

5 **计算体积**：通过比较落在椭球内部的点数和总点数，得出体积的估计值。体积的计算公式为：
   $$ V \approx \frac{N_{in}}{N_{total}} \times V_{box} $$
   其中 $N_{in}$ 是在椭球内部的点数，$N_{total}$ 是总点数，$V_{box}$ 是包围椭球的立方体的体积。

下面是完整的 Python 实现代码：

```python
import numpy as np

def monte_carlo_ellipsoid_volume(num_samples):
    # 设定椭球的系数
    a = np.sqrt(32)  # x^2/2 <= 16  -> x <= sqrt(32)
    b = np.sqrt(64)  # y^2/4 <= 16  -> y <= sqrt(64)
    c = np.sqrt(128) # z^2/8 <= 16  -> z <= sqrt(128)

    # 生成随机点
    x_samples = np.random.uniform(0, a, num_samples)
    y_samples = np.random.uniform(0, b, num_samples)
    z_samples = np.random.uniform(0, c, num_samples)

    # 计算在椭球内部的点
    inside_count = 0
    for x, y, z in zip(x_samples, y_samples, z_samples):
        if (x**2 / 2) + (y**2 / 4) + (z**2 / 8) <= 16:
            inside_count += 1

    # 计算体积
    volume_box = a * b * c  # 包围椭球的立方体体积
    volume_estimate = (inside_count / num_samples) * volume_box

    return volume_estimate

# 测试函数
num_samples = 1000000  # 选择足够大的样本数
estimated_volume = monte_carlo_ellipsoid_volume(num_samples)
print(f"Estimated volume of the ellipsoid in the first octant: {estimated_volume:.4f}")
```

代码说明：

- 我们首先设定了椭球的半轴长度($a$, $b$, $c$)，然后在随机生成的范围内采样。
- 对于每个点，我们检查它是否满足椭球方程并统计落在内部的点数。
- 最后，我们计算包围椭球的立方体体积并通过比例得到椭球的体积估计值。
- 你可以通过调整 `num_samples` 来提高准确性，样本越多，估计结果通常越精确。

输出结果：

```
Estimated volume of the ellipsoid in the first octant: 268.2982
```

真实结果：$64×8÷6×π=268.082573106329$

### 随机数的生成  

上一节提出了用蒙特卡罗模拟求面积和体积的算法，这些算法共同的要素是随机数。随机数有多种应用，包括博弈问题、计算面积和体积，以及诸如大规模战争演习、空中交通控制这样的复杂大系统的建模。

在某种意义上，计算机实际上不能生成随机数，因为它采用的是确定性算法。然而我们可以生成伪随机数序列，对于所有的实际场合它都可看作是随机的。纯粹的、最好的随机数发生器或者保证随机性的最好的检验方法是不存在的。

有一些完整的课程来研究随机数、深人的模拟方法和伪随机数发生器的检验，这里只是介绍一点随机数方法，它可以用来生成近似于随机的数列。

常用方法：

- 平方取中法
- 线性同余

### 随机行为的模拟  

1你到海滨度假，沮丧地听到当地气象台预报每天下雨的机会是50%。用蒙特卡罗模拟预测你的假期中有3天连续下雨的可能性。

2用蒙特卡罗模拟近似计算抛 5枚正规的硬币出现3个正面的概率。

3将一个正规般子连续掷100次，用蒙特卡罗方法模拟总和的结果。

问题 1：海滨度假期间连续3天下雨的可能性

我们将模拟假期的每一天，并在50%的概率下判断是否下雨。记录是否有连续3天下雨的情况，最后计算这种情况出现的比例。

```python
import numpy as np

def simulate_rainy_days(num_days, trials):
    rainy_streaks = 0

    for _ in range(trials):
        # 每一天有50%的机会下雨
        weather = np.random.binomial(1, 0.5, num_days)
        
        # 查找连续3天下雨的情况
        if any(np.convolve(weather, np.ones(3), 'valid') == 3):
            rainy_streaks += 1

    return rainy_streaks / trials

# 设置参数
num_days = 3  # 假期天数
trials = 10000  # 模拟次数

probability = simulate_rainy_days(num_days, trials)
print(f"Probability of having 3 consecutive rainy days: {probability:.4f}")
```

要确保模拟的结果与理论计算相符，我们需要确保在1次实验中仅考虑连续3天。如果不限制这一点，可能会导致计算上出现偏差。

问题 2：抛5枚硬币出现3个正面的概率

我们将模拟抛5枚硬币，并计算出现3个正面的次数，然后求出概率。

```python
import numpy as np  
  
# 定义函数模拟硬币抛掷  
def simulate_coin_tosses(num_tosses, trials):  
    successes = 0  
  
    for _ in range(trials):  
        # 每个硬币抛掷出正面的概率是0。5，使用二项分布模拟5次抛掷  
        heads = np.random.binomial(num_tosses, 0.5)  
  
        if heads == 3:  
            successes += 1  
  
    return successes / trials  
  
  
# 设置参数  
num_tosses = 5  # 抛掷次数  
trials = 10000  # 模拟次数  
  
probability = simulate_coin_tosses(num_tosses, trials)  
print(f"Probability of getting exactly 3 heads when tossing 5 coins: {probability:.4f}")
```

问题 3：掷100次骰子的总和

我们将模拟掷100次骰子并计算总和，记录多次实验的结果。

```python
import numpy as np  
  
# 定义函数模拟掷骰子100次的结果  def simulate_dice_rolls(num_rolls, trials):  
    sums = []  
  
    for _ in range(trials):  
        # 掷骰子，每个骰子的结果是1到6之间的整数  
        total_sum = np.sum(np。random.randint(1, 7, num_rolls))  
        sums。append(total_sum)  
  
    return sums  
  
# 设置参数  
num_rolls = 100  # 掷骰次数  
trials = 10000   # 模拟次数  
  
results = simulate_dice_rolls(num_rolls, trials)  
  
# 输出结果的统计信息  
mean_result = np.mean(results)  
std_dev_result = np.std(results)  
  
print(f"Mean of the sums after tossing a dice 100 times: {mean_result:.2f}")  
print(f"Standard deviation of the sums: {std_dev_result:.2f}")
```

代码分析

1 **问题 1**：该代码模拟假期每一天的天气，并检查是否有连续3天下雨。在10000次试验中计算出现这种情况的比例。

2 **问题 2**：代码模拟抛掷5枚硬币10000次，并统计得到3个正面的比例。

3 **问题 3**：代码模拟掷骰子100次，并计算总和的均值和标准差。

可以根据需要调整 `trials` 的值以提高结果的准确性。

研究课题：

- 纸牌游戏21点（Blackjack）
- 飞镖
- 双骰子赌博
- 赛马
- 轮盘赌
- 猜价游戏

赛马——构造并完成赛马的蒙特卡洛模拟。你可以利用报纸上提供的赔率，或者模拟由下面的参加者和赔率给出的数学赛马。

数学赛马

| 参加者的名字 | 赔率 |
| ------------ | ---- |
| Euler        | 7-1  |
| Leibniz      | 5-1  |
| Newton       | 9-1  |
| Cauchy       | 12-1 |
| Poisson      | 4-1  |
| L'Hopital    | 35-1 |
| Stokes       | 15-1 |
| Dantzig      | 4-1  |

构造并完成1000次赛马的蒙特卡罗模拟，哪一匹马胜的次数最多？哪一匹马胜的次数最少，这些结果令你惊奇吗？由输出结果给出每匹马胜多少次。

我们可以使用 Python 编写一个程序来模拟赛马的过程。我们将根据每位参与者的赔率生成随机结果并统计每匹马的胜利次数。赔率可以用于计算每匹马的获胜概率，从而影响胜出结果的分布。

接下来是基于您提供的参与者和赔率的实施步骤：

1 **赔率转换**：根据赔率计算每位马的获胜概率。
2 **模拟赛马**：进行1000次模拟，在每次模拟中，根据计算出的概率随机选择一匹马作为胜者。
3 **统计胜利次数**：记录每匹马赢得的次数。
4 **输出结果**：找出胜利次数最多和最少的马。

下面是具体的 Python 实现代码：

```python
import numpy as np
import pandas as pd

# 定义参与者及赔率
participants = {
    'Euler': 7,
    'Leibniz': 5,
    'Newton': 9,
    'Cauchy': 12,
    'Poisson': 4,
    'L\'Hopital': 35,
    'Stokes': 15,
    'Dantzig': 4
}

def calculate_probabilities(odds):
    """根据赔率计算每个参赛者的获胜概率。"""
    # 赔率的概率 = 1 / (赔率 + 1)，这里 +1 是因为赔率是赢得的赔率
    total_odds = sum(odds.values())
    probabilities = {horse: 1/(odds[horse] + 1) for horse in odds}
    return probabilities

def simulate_races(num_races, participants):
    """模拟赛马并统计每匹马的胜利次数。"""
    probabilities = calculate_probabilities(participants)
    results = {horse: 0 for horse in participants}  # 初始化胜利计数

    for _ in range(num_races):
        winner = np.random.choice(list(probabilities。keys()), p=list(probabilities。values()))
        results[winner] += 1  # 增加胜利次数

    return results

# 设置模拟次数
num_races = 1000
results = simulate_races(num_races, participants)

# 寻找胜利次数最多和最少的马
max_winner = max(results, key=results。get)
min_winner = min(results, key=results。get)

# 输出结果
print("Race Results after 1000 simulations:")
for horse, count in results.items():
    print(f"{horse}: {count} wins")

print(f"\nHorse with the maximum wins: {max_winner} with {results[max_winner]} wins")
print(f"Horse with the minimum wins: {min_winner} with {results[min_winner]} wins")
```

代码说明

1 **赔率和概率计算**:

   - 我们使用赔率来计算每匹马的获胜概率。赔率越低，获胜的概率越高。
   - 概率的计算公式为  $P(horse) = \frac{1}{odds + 1}$。我们将这些概率归一化，以确保它们加起来为1。
   - **概率归一化**：在计算概率的函数中，我们首先计算每个参与者的概率，然后在计算概率时，确保其总和为1。总和计算是相对的，所有赔率的反向分数加起来形成的总和会影响归一化后的每个赔率的概率。

2 **赛马模拟**:

   - 在模拟过程中，我们生成1000场比赛，并按概率选择获胜者。
   - 每当一匹马胜出时，增加对应马的胜利次数。

3 **结果统计**:

   - 根据统计结果找出胜利次数最多和最少的马。

运行结果

在输出的结果中，您将看到每匹马的胜利次数以及胜利次数最多和最少的马。根据模拟的随机性，您可能会发现一些马的胜利次数与赔率的期望结果有所偏差，这源于随机性和试验次数的影响。

可以运行以上代码并根据输出结果进行分析。

```
Race Results after 1000 simulations:
Euler: 125 wins
Leibniz: 193 wins
Newton: 98 wins
Cauchy: 81 wins
Poisson: 207 wins
L'Hopital: 18 wins
Stokes: 64 wins
Dantzig: 214 wins

Horse with the maximum wins: Dantzig with 214 wins
Horse with the minimum wins: L'Hopital with 18 wins
```

### 存储模型：汽油与消费需求  

### 排队模型  

例1港口系统  （单服务台排队）

例2早高峰时间 （多服务台排队）

写出计算机模拟程序，实现你喜爱的两支球队的棒球比赛。

我们可以使用蒙特卡洛模拟来模拟两支棒球队之间的比赛。以下是实现这一模拟的详细步骤和代码示例。

步骤说明

1 **确定基本参数**：

   - 设定两支球队的名字（如 Team A 和 Team B）。
   - 定义每支球队的进攻和防守能力。我们通过进攻能力（攻击力）和防守能力（防守力）来计算每局得分的概率。

2 **模型设计**：

   - 使用简单的模型来决定比赛的结果。进攻的球队每局得分的概率与其进攻能力相关，而防守的球队的防守能力会影响对方得分的概率。
   - 比赛通常是分多个局（如9局）进行，每局两队轮流进攻。

3 **模拟实施**：

   - 通过多次模拟（例如1000次），获取结果的统计信息，包括每支球队获胜的次数。

4 **确定比赛结果**：

   - 根据每次模拟的结果，输出每队的胜利次数以及赛季的总体表现。

以下是实现该模拟的Python代码：

```python
import numpy as np

# 设置球队及能力参数
class Team:
    def __init__(self, name, offense, defense):
        self.name = name
        self.offense = offense  # 进攻能力
        self.defense = defense    # 防守能力
        self.wins = 0

def simulate_inning(offensive_team, defensive_team):
    """模拟一局比赛，计算得分"""
    # 计算得分概率：进攻得分=进攻能力 / (进攻能力 + 防守能力)
    scoring_probability = offensive_team.offense / (offensive_team.offense + defensive_team.defense)
    
    # 随机生成0到1之间的分数
    return int(np.random.rand() < scoring_probability)

def simulate_game(team_a, team_b, innings=9):
    """模拟一场比赛，通过多局计算最终得分"""
    score_a = 0
    score_b = 0
    
    for _ in range(innings):
        score_a += simulate_inning(team_a, team_b)  # Team A 进攻
        score_b += simulate_inning(team_b, team_a)  # Team B 进攻
        
    return score_a, score_b

def simulate_season(team_a, team_b, num_games=1000):
    """模拟整个赛季"""
    for _ in range(num_games):
        score_a, score_b = simulate_game(team_a, team_b)
        
        if score_a > score_b:
            team_a.wins += 1
        elif score_b > score_a:
            team_b.wins += 1
    
    return team_a.wins, team_b.wins

# 创建球队实例
team_a = Team("Red Sox", offense=8, defense=6)
team_b = Team("Yankees", offense=7, defense=7)

# 模拟比赛
num_games = 1000
wins_a, wins_b = simulate_season(team_a, team_b, num_games)

# 输出结果
print(f"{team_a.name} won {wins_a} times.")
print(f"{team_b.name} won {wins_b} times.")
```

代码说明

1 **团队类定义**：

   - `Team` 类用于包含球队的基本信息，如名称、进攻能力和防守能力，以及胜利次数的记录。

2 **局的模拟**：

   - `simulate_inning` 函数用于模拟单局得分。通过概率决定进攻球队是否得分。

3 **比赛和赛季模拟**：

   - `simulate_game` 函数负责模拟完整局数的比赛并返回最终得分。
   - `simulate_season` 函数则进行多场比赛的模拟，根据得分决定每场比赛的胜者并增加胜利次数。

4 **参数设置**：

   - 进攻能力和防守能力可以根据两支球队的实际表现进行设定，数值越高表示更强的能力。

注意事项

- 进攻和防守能力的数值可以根据球队的真实能力进行调整以获得更真实的结果。
- 继续调整参数如局数和模拟次数，以获得关于球队表现更富有洞察的结果。
- 增加额外功能，比如数据可视化或者进一步的统计分析，可以提供更深入的比赛表现分析。

运行以上代码将模拟1000场红袜队和洋基队之间的比赛，返回每队的胜利次数。可以根据自己的需求更改球队名称、能力值和模拟次数。

## 离散概率模型  

我们已经利用比例和确定比例系数的方法建立了模型，但是，如果像加油站对汽油的需求量那样，实际过程中出现了变化怎么办？本章中将允许比例系数以随机形式改变，而不是固定不变。我们将从回顾离散动力系统开始，并介绍有随机参数的情况。

### 离散系统的概率模型  

本节将回顾之前讨论的差分方程组，但是允许方程组的系数随机地变化。一种特殊情况，称为马尔可夫链（Markov chain），是在任何给定时刻具有同样多个状态或结果的一个过程。这些状态不会重叠，并且覆盖所有可能的结果。在马尔可夫过程中，系统可以从一个状态转移到另一个，每个时段转移一次，并且这种向每个可能结果的转移存在一定的概率。在每个时段对于每个状态，从当前状态向下一状态的转移概率之和等于1。有两个状态的马尔可夫过程如下图所示。

![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250114094052.png)

例1再论汽车租赁公司  

例2投票趋势  

让我们概述马尔可夫链的概念。马尔可夫链是由具有以下性质的一系列事件构成的过程： 

1)一个事件有有限多个结果，称为状态，该过程总是这些状态中的一个。

2)在过程的每个阶段或时段，一个特定的结果可以从它现在的状态转移到任何其他状态，或者保持原有状态。

3)每个阶段从一个状态转移到其他状态的概率表示为转移矩阵，矩阵每行的各元素在0到1之间，每行的和为1，这些概率只取决于当前状态，而与过去状态无关。

### 部件和系统可靠性建模  

人一机系统，无论是电子的还是机械的，都由若干部件组成，一些部件结合成为子系统（如你的个人电脑、立体声音响或汽车这样的系统）。我们想建立简单的模型来检查复杂系统的可靠性，计划考虑串联、并联或者串并联结合几种关系。虽然单个零件的失效率可能服从多个不同的分布，但下面只讨论几个基本的例子。

例1串联系统  

整个串联系统的可靠性小于任何单个部件的可靠性，因为每个部件的可靠性小于1。

例2并联系统  

并联系统的可靠性大于任何单个部件的可靠性。

例3串并联组合系统  

### 线性回归  

第3章讨论了对收集的数据拟合模型的几个准则，特别提出了使偏差平方和最小的最小二乘准则，并说明偏差平方和的最小化是一个优化问题。在此之前对自变量的每一个值$x_i$只考虑一个观测值$y_i$，然而如果有多个观测值呢？这一节研究一种偏差平方和最小化的统计方法，称为线性回归，任务是

1)阐述基本的线性回归模型和它的假设。

2)定义并解释统计量 R²

3)利用检查和解释残差散点图对拟合线性回归模型做图形说明。

这里只介绍基本概念和解释，关于线性回归更深人的研究请看进一步的统计教程。

例1美国黄松  

例2再论钓鱼比赛  

## 离散模型的优化  

在第3章中，用选定的模型对一组数据进行拟合时，我们考虑过三种准则： 

1)最小化绝对偏差的和；

2)最小化绝对偏差的最大值(Chebyshev 准则）; 

3)最小化绝对偏差的平方和(最小二乘准则)。

### 离散优化建模概述  

例1确定生产计划方案  

优化问题有多种分类方法。这些分类方法并不是相互排斥的，而是表明了所研究的问题所具有的某些数学特征。我们下面给出一些分类方法。

如果一个优化问题没有约束条件，该优化问题称为无约束的；如果有一个或多个边界条件，该优化问题称为有约束的。

如果一个优化问题满足以下性质，该优化问题称为线性规划： 

1)有惟一的目标函数。

2)当一个决策变量出现在目标函数和任何约束函数中的时候，它只以一次幂的形式出现（可以乘以一个常数）。

3)目标函数和任何约束函数中不包含决策变量的乘积项。

4)目标函数和任何约束函数中决策变量的系数是常数。

5)决策变量的取值可以是整数，也可以是分数。

这些性质保证了决策变量的影响效果与其取值是成比例的。下面对以上每条性质做进一步的说明。

性质1将问题限定为单一目标函数。目标函数多于1个的问题称为多目标或目标规划。性质2和3的含义是不言自明的，如果一个优化问题不满足其中的任何一条，它就是非线性的。例1中的第一个生产计划问题的目标函数中，两个决策变量都有二次项，因此不满足性质2。对于你希望建模的许多情况，性质4是非常严格的。在考虑生产桌子和书架所需要的木板和劳动时间时，精确知道生产每种产品所需要的木板和劳动时间是可能的，因此可以将它们写进约束条件．然而经常遇到的情况是，事先准确预测模型必需的某些数值是不可能的（如预测玉米的市场价格），或者这些系数只是代表了实际值的平均值，而平均值与实际值可能有比较大的偏差。这些系数可能也是和时间相关的，有一类与时间相关的问题称为动态规划。如果系数不是常数，而是本质上是随机的，那么问题称为随机规划。最后，如果一个或多个决策变量被限定为只取整数值(因此不满足性质5)，这样的问题称为整数规划（如果只有部分决策变量限定为整数，问题称为混合整数规划)。例1中生产计划问题的变形问题中，在确定周生产计划时允许桌子和书架的生产数量取分数值是合理的，因为它们可以继续在下周完成。

例2航天飞机的载货问题 （背包问题）

例3分段线性函数逼近  

多目标规划：投资问题

动态规划问题

一种经常出现的情况是，优化模型要求在不同的时间区间上分别进行决策，而不是一次做出全部决策。在 20 世纪 50 年代，美国数学家 Richard Bellman 发明了一种对这类模型分阶段优化而不是一次优化的技术，这样的方法称为动态规划。下面的问题就是一个可以用动态规划求解的例子：

某牧场主从事养牛业．开始时他有$k$头牛，并计划$N$年后卖出全部牛而退休。每年他都面临以下问题：卖掉多少头牛？保留多少头牛？如果在第$i$年卖出若干头牛，估计每头牛利润为$p_i$；而第i年保留下来的牛，到第$i+1$ 年的时候数量会翻倍。

用第 2章中介绍的建模过程分析下面的情景。 当用该建模过程分析清楚需要解决的问题后，你会发现在建立优化模型前，用自然语言回答下面的问题是很有帮助的：
(a)识别决策变量：需要做出什么样的决策？
(b)建立目标函数：决策如何影响目标？
(c)建立约束集合：必须满足什么样的约束？请一定思考一下：该问题中决策变量是否允许取负数？并保证：如果允许取负数，约束确实是这样建立的。

建立模型后，请检查线性规划的假设条件是否成立，并将模型的形式与本节给出的例子进行比较。 尽量确定什么样的优化方法能用于获得该问题的最优解。

典型问题：

- 资源分配
- 营养需求
- 生产计划
- 果仁混合
- 电子设备的生产
- 卡车采购
- 农作问题

### 线性规划（一）：几何解法  

![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250114100908.png)

例1木匠问题  

例2数据拟合问题  

定理1：假设线性规划的可行域是非空有界凸集，则目标函数一定会在可行域的极点上取到最大值和最小值，如果可行域无界，目标函数不一定能取到最优值；然而，如果最大值和最小值确实存在，则一定也会在某个极点上取到。

这个定理保证了线性规划至少有1个最优解来自于非空有界凸集的极点。

### 线性规划（二）：代数解法  

例1木匠问题的代数解法  

### 线性规划（三）：单纯形法  

到目前为止，通过在用决策变量和松弛变量表示的交点中搜索，我们已经学会了找到最优的极点。能不能减少在搜索过程中考虑的交点的数量呢？当然，一旦找到了一个可行的初始交点，就没有必要再考虑那些对目标函数值没有改进的潜在交点。能不能检验当前解相对于其他可能的交点的最优性呢？即使一个交点比当前解更优，如果它不能满足约束条件，我们对它也没有兴趣。能不能检验一个交点是不可行的呢？George Dantzig 发明的单纯形方法，融合了最优性检验和可行性检验，从而找到线性规划问题的最优解(如果最优解存在的话)。

所谓最优性检验，是判断一个交点对应的目标函数值是否比当前找到的最好结果更优。所谓可行性检验，是确定一个交点是否可行。

为了实现单纯形方法，首先将决策变量和松弛变量分成两个互不相交的集合，即独立变量集合和相关变量集合。对于我们考虑的特殊线性规划来说，初始的独立变量集合由决策变量组成，而松弛变量属于相关变量集合。

例1再论木匠问题  

例2使用单纯形表  

因为最下面一行中没有负的系数，$x_1 =3$ 和 $x_2=0$ 就是最优解，最优目标函数值为 9。

我们可以使用 Python 的 `scipy.optimize` 模块来求解这个线性规划问题，采用单纯形法进行求解。以下是根据你给出的线性规划问题的详细实现步骤。

我们需要解决的线性规划问题包括：

**目标函数：**

$$\text{max } 3x_1 + x_2$$

**约束条件：**

$$\begin{align*}
2x_1 + x_2 & \leq 6 \\
x_1 + 3x_2 & \leq 9 \\
x_1, x_2 & \geq 0
\end{align*}$$

转换为标准形式

- **目标函数的最小化形式：**

$$
\text{min } -3x_1 - x_2
$$

- **约束条件：**
  -  $2x_1 + x_2 \leq 6$
  -  $x_1 + 3x_2 \leq 9$
  -  $x_1, x_2 \geq 0$

以下是相应的 Python 实现代码：

```python
import numpy as np
from scipy.optimize import linprog

# 定义目标函数的系数（取负以进行最小化）
c = [-3, -1]  # 目标函数为 -3x1 - x2

# 定义约束条件的系数（左侧）
A = [
    [2, 1],   # 2x1 + x2
    [1, 3]    # x1 + 3x2
]

# 定义约束条件的右侧
b = [6, 9]  # 对应约束条件右侧的值

# 定义变量的边界条件，对于 x1 和 x2 都是 >= 0
x_bounds = (0, None)

# 使用 linprog 进行线性规划求解，采用单纯形法
result = linprog(c, A_ub=A, b_ub=b, bounds=[x_bounds, x_bounds], method='highs')

# 输出结果
if result.success:
    print(f'Optimal value: {-result.fun}')  # 取负得到最大值
    print(f'x1 = {result.x[0]}, x2 = {result.x[1]}')
else:
    print('No solution found!')
```

代码说明

1. **目标函数系数**: `c` 中包含目标函数的负值部分以满足最小化的要求。
2. **约束条件**: `A` 和 `b` 定义了不等式约束，其中 `A` 表示左边的系数，`b` 表示右边的常数。
3. **边界条件**: `x_bounds` 确保 $x_1$ 和 $x_2$ 的值均为非负。
4. **求解问题**: 使用 `linprog` 函数，并指定约束和目标函数。
5. **结果输出**: 如果成功，输出最优解和对应的 $x_1, x_2$ 值。

输出结果如下所示：

```
Optimal value: 9.0
x1 = 3.0, x2 = 0.0
```

### 线性规划（四）：敏感性分析  

最优解对目标函数中的系数变化的敏感性

资源改变一个单位的经济学解释

在对线性规划进行解释的时候，敏感性分析是一种强有力的方法。仔细地进行敏感性分析所得到的信息，对决策者来说至少和线性规划的最优解具有同等的价值。在高级的优化课程里，你可以学到如何用代数方法进行敏感性分析。此外，与右端项一样，对约束集合的系数，也能够进行敏感性分析。

### 数值搜索方法  

如果希望在某个区间`[a，b]`上使可微函数f(x)最大化，我们已经知道可以令其一阶导数为0，求出驻点。然后，可以用二阶导数判断这些驻点的特性。我们还知道，必须检查区间的端点，以及区间内不存在一阶导数的点。然而，设定一阶导数为0以后所导出的方程，可能没有代数方法可以求解。在这样的情况下，可以采用搜索过程来逼近最优解。

对于只含有一个独立变量的非线性优化问题，可以用不同的方法逼近最优解。二分法和黄金分割法是两种常用的方法，它们与大多数搜索方法有许多共同的特点。

例1二分搜索方法  

黄金分割搜索方法采用黄金比值(黄金数)进行搜索。当 整 个 区 间 的 长 度 与 较 长 } 线段的长度的比值等于较长线段的长度与较短线段的长度的比值时，我们就称这两个区间以黄金比值分割。用数学符号表示，就是$1/r=r/(1-r)$,即$r^2+ r- 1= 0$ 这里 $r>1-$r

例2黄金分割搜索方法  

例3再论模型拟合准则  

例4工业流程优化  

斐波那契搜索

牛顿插值法

## 量纲分析和相似性

### 表示为乘积形式的量纲

量纲分析在真实问题中的应用以下述假设为基础：问题的解是由依据适当变量的齐性方程给出的。因而，我们的任务是通过寻求一个适当的无量纲方程来确定待定方程的形式，之后把因变量解出来，为了完成这项任务，我们必须决定哪些变量进人研究的物理问题，并且在它们中间确定所有无量纲乘积。一般地，有无限多个这样的乘积，所以，必须对它们进行说明而不是实际上写出来。而后，这些无量纲的某些子集就用来构造量纲齐性方程。在8.2节我们研究如何利用无量纲乘积来寻找所有的量纲齐性方程。下面的例子说明无量纲乘积是如何找到的。

例1 再论单摆

例2 作用在箱式运货车上的风力

### 量纲分析的步骤

例1 雨滴的落地速度

例2 再论汽车油耗问题

### 一个阻尼摆

在竞争的模型中间择优

在建立模型过程中的量纲分析

### 解释量纲分析的几个例子

例1 爆炸分析

例2 烤火鸡应当烤多久？

### 相似性

假如，我们对于海浪拍击巨轮的效应，以及潜艇的热损耗和在水下环境中经受的阻力，或者，作用在飞机机翼上的风力都饶有兴趣。通常，由于在实验室中重复实际的现象是不可能的，我们就在模拟的环境中研究经过缩减的模型来精确预测物理系统的性能。这个实际物理系统称为原型。我们怎样在实验室中调节实验比例，从而确保对模型观察到的效应与原型经受的效应相互一致？

使用模拟方法固然要十分小心，但由对于问题的量纲分析得到的量纲乘积，可以使人们深人了解应当怎样调节模型比例。这个想法来源于 Buckingham 定理．如果物理系统可以由各个变量的量纲齐次方程来描述，那么，对于一个完备无量纲乘积组，它可以表述为如下的形式：

$$f(\prod_1,\prod_2,\cdotp\cdotp\cdotp,\prod_n)=0$$

假定，问题的因变量只是出现在乘积$\Pi_n$中而且
$$\prod_n=H(\prod_1,\prod_2,\cdotp\cdotp\cdotp,\prod_{n-1})$$
为了模型的解和原型的解彼此相同，只需所有独立无量纲乘积$\Pi_1,\Pi_2, \dots, \Pi_n$对于模型和原型是相同的。

例1：作用在潜艇上的阻力

## 函数图表构成模型

### 军备竞赛

例1 民防

例2 移动发射台

例3 多弹头

例4 再论多弹头分导再入运载系统：弹头计数

### 对分阶段军备竞赛建立模型

### 管理不可再生资源：能源危机

### 税收对于能源危机的影响

### 汽油短缺和税收


## 用微分方程建模  

### 人口增长  

马尔萨斯人口增长模型$P(t)=P_0\operatorname{e}^{k(t-t_0)}$

反映有限增长的改进模型  逻辑斯蒂曲线

$$P(t)=\frac{\boldsymbol{M}\boldsymbol{P}_0}{\left[\boldsymbol{P}_0+(\boldsymbol{M}-\boldsymbol{P}_0)\boldsymbol{e}^{-\boldsymbol{r}\boldsymbol{M}(t-\boldsymbol{t}_0)}\right]}$$

$K/2$时增长率最大

有限增长模型的检验

社会学家发现了一种被称为社会流传的现象，指的是一条信息、一项技术创新或一种文化时尚在人群中的传播。这样的人群可以分为两类：一类接收到该信息，另一类没有。在一个人口数量已知的固定人群中，有理由假设流传率与已接收到信息的人数和待接收的人数的乘积成正比。若X表示N个人的居民中已接收到信息的人数，那么关于社会流传的数学模型为 dX/dt=kX(N一X)，其中 t 表示时间，k 是正常数。

(a)解这个模型，并证明它的解是一条逻辑斯蒂曲线。

(b)什么时候此信息传播最快？

(c)最终会有多少人接收到此信息？



### 对药剂量开处方  

### 再论刹车距离  

### 自治微分方程的图形解  

微分方程当 $dy/dx$ 仅仅是 y 的函数时，就称为自治微分方程。

定义 若 $dy/dx=g(y)$是自治微分方程，则使得$dy/dx=0$ 的 y值就称为平衡点或静止点。

因而，平衡点是使因变量不再发生变化的那些点，所以 y 是静止的。这里强调的是使$dy/ dx= 0$的 y 值，而不是上节中所用的 $x$ 值。比如，d$y/ dx= ( y+ 1) ( y- 2)$的平衡点是 $y^\prime=$ -1 和$y=2$。

为构造自治微分方程的图形解，我们先作方程的一条相直线(phase line),它是 y轴上的图， 且标明了方程的平衡点及使 $dy/dx$和 $d^2y/dx^2$ 取正负的区间。于是我们就能知道解在何 处增减以及解曲线的凸性。这些就是在不必求出解公式的情况下来确定解曲线形状所需要的基本特征。

例1画相直线及解曲线的草图  

![](https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250115094854.png)

例2汤的冷却  

例3再论逻辑斯谛增长  

### 数值近似方法  

一阶初值问题

初值问题的近似解

例1欧拉法的运用  

问题定义

我们要解决的微分方程是：$y' = 1 + y$
初始条件是：$y(0) = 1$

步骤

1. 设置初始值 $y(0) = 1$。
2. 选择步长 $\Delta r = 0.1$。
3. 用欧拉法更新 $y$ 的值。

欧拉法公式

在欧拉法中，下一步的值通过以下公式计算：
$y_{n+1} = y_n + \Delta r \cdot f(t_n, y_n)$

在这里：

- $t_n$ 是当前的 $r$ 值（即 $r_n$）。
- $y_n$ 是当前的 $y$ 值。
- $f(t_n, y_n)$ 是微分方程右边的表达式，即 $1 + y_n$。

下面是实现这一过程的 Python 代码：

```python
# 定义欧拉法函数  
def euler_method(initial_y, delta_r, steps):  
    # 初始化 y 的值列表  
    y_values = [initial_y]  
  
    # 欧拉法计算  
    for _ in range(steps):  
        # 当前 y 值  
        current_y = y_values[-1]  
  
        # 根据欧拉法公式更新 y 的值  
        next_y = current_y + delta_r * (1 + current_y)  
  
        # 将下一个 y 值添加到列表中  
        y_values.append(next_y)  
  
    return y_values  
  
  
# 初始化参数  
initial_y = 1  # y(0) = 1  
delta_r = 0.1  # 步长  
steps = 3  # 计算 y_1, y_2, y_3 的近似值  
  
# 调用欧拉法计算  
y_values = euler_method(initial_y, delta_r, steps)  
  
# 输出最终的 y 值  
for i, y in enumerate(y_values):  
    print(f"y_{i} = {y:.4f}")
```

运行上述代码时得到以下结果（根据欧拉法计算得到的近似值）：

```
y_0 = 1.0000
y_1 = 1.2000
y_2 = 1.4200
y_3 = 1.6620
```


例2再论储蓄存单  

### 分离变量法  

## 用微分方程组建模  

### 一阶自治微分方程组的图形解  

例1线性自治微分方程组  

例2非线性自治微分方程组  

### 竞争捕猎模型  

### 捕食者食饵模型  

### 两个军事方面的例子  

例1Lanchester战斗模型  

$\frac{\mathrm{d}x}{\mathrm{d}t}=-ay$

$\frac{\mathrm{d}y}{\mathrm{d}t}=-bx$

例2军备竞赛的经济方面  

### 微分方程组的欧拉方法  

例1方程组的欧拉方法应用  

例2轨线和解曲线  

## 连续模型的优化  

### 库存问题：送货费用和储存费用最小化  

### 制造问题：竞争性产品生产中的利润最大化

在许多建模的情形，我们需要优化含有多个独立变量的函数。在本节，我们介绍一种含有两个无约束的独立变量的情形。我们用两种方法找到最优解：普通的多变量微积分方法（令偏导数为0，解变量构成的方程组），以及梯度搜索算法。

### 连续约束优化  

在建立一个优化模型时，有时需要考虑自变量被限制在平面的一些特定子集（如圆盘、直线、封闭的三角形区域)内时的最大值和最小值。本节我们给出这种约束问题的两个例子，并介绍一种求极值的强有力方法———Lagrange 乘子法。

例1石油转运公司  

例2航天飞机的水箱  

### 可再生资源的管理：渔业  

## 附录A 美国大学生数学建模竞赛试题(1985～2004)  

## 附录B 电梯问题的模拟算法  

## 附录C 修正单纯形法







